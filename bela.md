# Csound and Bela: touching opcodes

## What is Csound?

[Csound](https://csound.com/) is an audio software and programming language for sound synthesis and composition. It was developed by Barry Vercoe at MIT Media Lab in 1986, but its roots goes all the way back to Music III developed by Max Matthews in 1961. Today Csound is developed by a group of core developers with a wider community of volunteers contributing. One of the main principles in Csound development is to guarantee backwards compatibility. You can still run Csound source files from 1986 on the latest Csound release.

Although Csound has a strong tradition as a tool for composing electro-acoustic pieces and traditionally has been used in a non-interactive score driven context, nowadays it is mostly used in in a real-time context. Csound can run on a host of different platforms including all major operating systems as well as Android and iOS. Csound can also be called through other programming languages such as Python, Lua, C/C++, Java, etc. and now finally also on Bela!


## Writing a Csound instrument
Csound documents are simple text documents starting with the XML type tag <CsoundSynthesizer> and are then structured into 3 sections: a) CsOptions, b) CsInstruments, and c) CsScore

```
<CsoundSynthesizer>

<CsOptions>
</CsOptions>

<CsInstruments>
</CsInstruments>  

<CsScore>
</CsScore>

</CsoundSynthesizer>
```

Each section of Csound code has its on [syntax and grammar](https://csound.com/get-started.html). The first couple of lines are mainly some [hardware/software settings](https://csound.com/docs/manual/Using.html), which for now we can ignore.

Where the fun starts is with defining instruments (or setting up patches). An instrument can be written between the *instr* and *endin* lines. Instruments are build by combining signal processing modules which are called *opcodes* in Csound. There are [thousands of opcodes](https://csound.com/docs/manual/PartOpcodesOverview.html) available for different kinds of oscillators, filters, envelopes, delays, reverbs, sample manipulation tools and so on. The [Csound Reference Manual](https://csound.com/docs/manual/PartReference.html) provides more information and examples for each available opcode.


Here we will start right into writing a first simple instrument which uses a [*pink noise*](https://csound.com/docs/manual/pinker.html) generator, a [simple sine oscillator](https://csound.com/docs/manual/oscils.html), two [LFOs](https://csound.com/docs/manual/lfo.html) and an opcode for [stereo panning](https://csound.com/docs/manual/pan2.html). The output of an opcode is assigned to a variable e.g. aNoise is the holder for the audio signal generated by the *pinker* opcode. Here, Csound has specific [variable types](http://www.csounds.com/journal/issue10/CsoundRates.html) for the data to hold. The first letter of a variable name sets the type, in this case aNoise expects an a-rate (audio) signal. Other types you will often find are k-rate (control rate) signals, that are updated less frequently to save computing power and i-rate signals which can only be set once, when the instrument is instantiated.

In the CsScore section instruments can be called by their name or number. In this case *instr 1* is called 4 times with different settings for p4 and p5. This is the most straight forward way to run instruments, although other options like triggering by [MIDI events](http://write.flossmanuals.net/csound/b-triggering-instrument-instances/) and triggering [live-events](http://write.flossmanuals.net/csound/f-live-events/) from within other instruments is worth to check out.


```
<CsoundSynthesizer>

<CsOptions>
-odac -iadc
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 8
nchnls = 2
0dbfs = 1.0

instr 1
  aNoise pinker                 ; pink noise
  aSin poscil 0.4, p4           ; sine oscillator
  aLFO1 lfo 0.7, p5, 3          ; LFO - square (unipolar)
  aLFO2 lfo 0.7, .3, 2          ; LFO - square (bipolar)
  aSig = (aLFO1 * aNoise) + (aLFO2 * aSin)  ; crazy mixing
  aSigL, aSigR pan2 aSig, aLFO1-aLFO2       ; insane panning
  outs aSigL, aSigR             ; stereo output
endin

</CsInstruments>

<CsScore>
;Ins St Dur sinFq lfoFq
  i1 0  2    250    2
  i1 +  2     50   10
  i1 +  2   1500   .5
  i1 +  1     50   10
</CsScore>

</CsoundSynthesizer>
```

## Csound and Bela

The idea to run Csound on the Bela Board came from the [COSMO-project](http://cosmoproject.github.io/) (Csound On Stage: Music Operator), which is a project devoted to making hardware- and software frameworks for making embedded standalone Csound instruments to use on stage. The COSMO team originally worked with Raspberry-Pi's but that always required some custom hardware, for better sound quality, adequate latency, and individual controller inputs. All these hardware requirements are already met by the Bela boards, so it was only a matter to bring Csound into the Bela platform.
A small team around Bernt I. Waerstad, Victor Lazzarini and [Alex Hofmann](https://homepage.univie.ac.at/alex.hofmann/) started to work on this project in Autumn 2017 and the first release of BelaCsound was pubished in July 2018.

<iframe src="https://player.vimeo.com/video/183101272" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p><a href="https://vimeo.com/183101272">COSMO - Csound On Stage Music Operator</a>


### Getting started

Bela comes with a very nice browser based IDE (see [https://github.com/BelaPlatform/Bela/wiki/Getting-started-with-Bela](https://github.com/BelaPlatform/Bela/wiki/Getting-started-with-Bela) for an introduction on how to install necessary drivers and accessing the IDE) which makes developing and setting up a Bela with Csound extremely easy. To get started, you simply click "Create new project", select ```Csound``` as project type and type in your desired name for the project. This will automatically create a default example project which introduces some key concepts like how to read in values from the analog pins and how to turn an LED on and off. Other and more advanced concepts can be explored in the Examples section under ```Csound```

TODO: Put in screenshot of IDE creating a new project


I've never used this - is it relevant?
- from commandline > belacsound --csd xyz.csd

### Bela inputs and outputs in Csound

To communicate with the analog channels on the Bela, we're using the Csound channel system. The input channels are named ```analogIn0``` to ```analogIn7``` and output channels ```analogOut0``` to ```analogOut7```. To read values, we use the [chnget](https://csound.com/docs/manual/chnget.html) opcode and [chnset](https://csound.com/docs/manual/chnset.html) is used to write values. Note that these are a-rate channels, so a downsampling is needed if you want to use the input values as k-rate control signals 

	;------------------------------------------------------
	;  	Simple AM synth with analoge in and out
	;------------------------------------------------------

	instr 1

		; Analog in 0 controls carrier frequency
		aCarFreq chnget "analogIn0"
		aCarFreq = (aCarFreq * 1000) + 50
		kCarFreq = k(aCarFreq) ; downsampling from a-rate to k-rate

		; Analog in 1 controls modulator frequency
		aModFreq chnget "analogIn1"
		aModFreq *= 100
		kModFreq = k(aModFreq)

		; Analog in 2 controls modulator amount
		aAM_vol init 1
		aAM_vol chnget "analogIn2"
		

		; Modulator
		aMod oscil aAM_vol*0.5, kModFreq
		aMod += 0.5

		; Carrier with envelope
		kEnv adsr 0.1, 0, 0.8, 0.3
		aCar poscil 0.8*kEnv, kCarFreq
		aOut = aCar * aMod

		; Set LED to blink in time
		; with modulation frequency
		
		chnset aMod, "analogOut0"

		outs aOut, aOut
		
	endin


### What is easy to accomplish with Csound ?

#### Effect processor using COSMO dsp-library

The cosmo-dsp repository comprises a library of ready-made audio effects (e.g Reverb, Delay, Distortion ..). All effects are set up as independendant modules that can be combined to a custom setup of effects. To use one of the readymade effects, you first need to include the file containing the effect like this

	#include "../DSP-Library/Effects/Reverb.udo"
	#include "../DSP-Library/Effects/Lowpass.udo"

Since the Csound code is placed in separate files, we need these lines to include the actual code for Reverb and Lowpass. If we wanted to use e.g. the TapeDelay effect we would need to add the line #include "../DSP-Library/Effects/TapeDelay.csd".

IMPORTANT! The paths used in the example is based on the placement of the example files within the cosmo-dsp directory structure. If you want to modify this example instead of starting from scratch, see start of section 2. Basic Csound on COSMO for explanation of how to make a local copy and do the necessesary modifications.

instr 1 
    #include "../DSP-Library/Includes/adc_channels.inc"
    #include "../DSP-Library/Includes/gpio_channels.inc"
The two first files includes the code for reading the knobs, switches and leds. The values from these are put into global control rate variables called gkpotX, gkswitchX and gkledX accordingly (the X represents the number (0-indexed) of the controller, so the first knob would get the name gkpot0

aL, aR ins
This is the code for getting audio into Csound. ins is a Csound opcode (a native Csound module) which ouputs the incoming audio into the audio rate variables aL and aR

; Reverb arguments: decay, cutoff, mix
aL, aR Reverb aL, aR, gkpot0, gkpot1, gkswitch0

Reverb is a UDO (User Defined Opcode) which takes a stereo input signal with 3 arguments (decay, cutoff and mix) and applies reverberation to the signal. The ouput is also a stereo signal. Notice that aL and aR are used on both right and left side of Reverb; this means that we first send the dry signal into the reverb effect and then overwrite the dry signal with the reverberant signal. This way makes it very easy to switch the order of effects without changing any code - you simply just reorder by switching lines.

The arguments are where set up how you use your knobs and switches to control the different effects. In this example the two first knobs will control the decay time and lowpass filter cutoff, while the first switch will turn the effect on and off (by sending 0 or 1 to the mix argument). All scaling are done inside the effects, so all input arguments should be normalized (0 to 1).

; Lowpass_Stereo arguments: cutoff, resonance
aL, aR Lowpass_Stereo aL, aR, gkpot2, gkpot3
Here a stereo lowpass filter is applied to the signal coming out from the reverb effect. Knob 3 and 4 are set up to control the filter cutoff and resonance respectively. The lowpass filter also have a distortion argument which we don’t use here. All effects are made in this way so actually all arguments are optional, but only in the order they are placed (e.g. you can’t skip resonance and then include distortion).

outs aL, aR
The audio coming out from the lowpass filter are sent to the outs opcode which sends the audio to the actual hardware device (sound card).



#### MIDI controlled synthesizer

a) One thing where, in my opinion, Csound outperforms other environments is how quick you can write a MIDI synthesizer. This comes in very handy in combination with Bela, as you can connect any class-compliant MIDI-keyboard to the USB-port of Bela, load a Csound instrument and play it like a synth.

In the Csound Options, you can select the MIDI-device you'd like to control csound with. As a default, the MIDI channel defines the instrument number which is called for each pressed key, this could be changed by setting [massign](https://csound.com/docs/manual/massign.html).
To avoid cpu overload by triggering too many voices in parallel, the [maxalloc](https://csound.com/docs/manual/maxalloc.html) option allows to restrict the maximum number of voices (in this example set to 4 voices).

```
<CsoundSynthesizer>
<CsOptions>
-Mhw:1,0,0 -+rtmidi=NULL --daemon
</CsOptions>
<CsInstruments>

; Initialize global variables.
sr = 44100
ksmps = 8
nchnls = 2
0dbfs = 1

seed 0 ; init random function
maxalloc 1, 4 ; restrict to maximum 4 voices

;------------------------------------------------------
; Instrument will be played by MIDI notes on Channel 1
;------------------------------------------------------
instr 1
	iFreq cpsmidi
	iAmp ampmidi 0.3

	; Three detuned sawtooth oscillators
	aOut1 = vco2(iAmp, iFreq)
	aOut2 = vco2(iAmp, iFreq*1.004)
	aOut3 = vco2(iAmp, iFreq*0.995)

	; Envelope
	aOut = aOut1 + aOut2*0.5 + aOut3*0.5
	aEnv linsegr 0, 0.01, 0.1, 0.2, 0

	; Filter LFO and envelope
	kLFO = lfo(50, 1.2, 0)
	aFiltEnv linsegr 100, 1.2, 1000, 0.2, 0

	; Korg35 resonant low-pass filter
	aOut = K35_lpf(aOut, aFiltEnv+kLFO, 9.4, 0, 1)

	; Voice panning
	iPan random 0.2, 0.8;
	aOutL, aOutR pan2 aOut, iPan

	; Output
	outs aOutL*aEnv, aOutR*aEnv
endin


</CsInstruments>
<CsScore>
</CsScore>
</CsoundSynthesizer>
```

### Good programming practices for Bela

Programming for real-time systems requires a few considerations that you normally don't have to think about. First of all, prints should always be avoided unless you're debugging. In Csound printing and other console messages can be suppressed by adding ```-m0d``` to the ```<CsOptions>``` section. Loading files from disk should also be avoided (for instance loading audio files with ```diskin2```), but should rather be loaded into memory with function table generators. Using ```reinit``` to re-initialize i-rate variables should also be avoided if possible as it can cause a mode switch which normally leads to a drop-out. 

TODO: put in examples code for loading audio to ftable


### What's next?

- Scopes: for now only scope channel is implemented
- More examples: we aim to develop more interesting examples of how to use Csound on Bela in the future

#### Projects made with COSMO (Bela + Csound)

##### Alex saxophone

##### Electroacoustic guitar

##### 


